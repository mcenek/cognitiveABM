/**

This code represents the decision making and information for a single hill climber agent.

What does it do: Upon each step the agent moves to what it thinks is the next best location, based upon either the perceptron output or the q-learning module.

This code was originally generated by the Mars library, then we altered it to use the perceptron as a part of it's decision making process.

*/

namespace HillClimberExample
{
    using System;
    using System.Linq;
    using Mars.Interfaces.Layer;
    using Mars.Components.Environments;
    using Mars.Common.Logging;
    using System.Collections.Generic;
    using CognitiveABM.Perceptron;
    using CognitiveABM.QLearning;
    using System.IO;
    using System.Collections.Concurrent;



    public class Animal : Mars.Interfaces.Agent.IMarsDslAgent
    {
        private static readonly ILogger _Logger = LoggerFactory.GetLogger(typeof(Animal));


        private readonly float[] AgentMemory;

        private readonly int startingElevation;

        public Guid ID { get; }

        public Mars.Interfaces.Environment.Position Position { get; set; }

        public bool Equals(Animal other) => Equals(ID, other.ID);

        public override int GetHashCode() => ID.GetHashCode();

        public QLearning qLearn = new QLearning();

        public int tickNum = 0;

        private string rule = default;

        public static ConcurrentDictionary<int, List<Tuple<int, int>>> memory; //list of where its been

        public string Rule
        {
            get => rule;
            set
            {
                if (rule != value) rule = value;
            }
        }

        private int animalId = default;

        public int AnimalId
        {
            get => animalId;
            set
            {
                if (animalId != value) animalId = value;
            }
        }

        private int bioEnergy = default;

        public int BioEnergy
        {
            get => bioEnergy;
            set
            {
                if (bioEnergy != value) bioEnergy = value;
            }
        }

        private int elevation = default;

        public int Elevation
        {
            get => elevation;
            set
            {
                if (elevation != value) elevation = value;
            }
        }

        internal int executionFrequency;

        public Terrain Terrain { get; set; }

        [Mars.Interfaces.LIFECapabilities.PublishForMappingInMars]
        public Animal(Guid _id, Terrain _layer, RegisterAgent _register, UnregisterAgent _unregister, SpatialHashEnvironment<Animal> _AnimalEnvironment, int AnimalId, double xcor = 0, double ycor = 0, int freq = 1)
        {
            ID = _id;
            Terrain = _layer;
            this.AnimalId = AnimalId;
            executionFrequency = freq;

            Position = Mars.Interfaces.Environment.Position.CreatePosition(xcor, ycor);
            var pos = InitialPosition();
            Position = Mars.Interfaces.Environment.Position.CreatePosition(pos.Item1, pos.Item2);

            Terrain._AnimalEnvironment.Insert(this);
            _register(_layer, this, freq);


            Elevation = Terrain.GetIntegerValue(Position.X, Position.Y);
            startingElevation = Elevation;

            memory = new ConcurrentDictionary<int, List<Tuple<int, int>>>();

            //AgentMemory is functionally useless right now
            //it goes into perceptron, but it's useage is commented out
            AgentMemory = new float[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        }

        // Tick function is called on each step of the simulation
        public void Tick()
        {

            /**FCM*/
            //-----FCM----//

            Tuple<List<float>, List<float>> adjacentTerrainTuple = GetAdjacentTerrainInfo();
            float[] adjacentTerrainElevations =  adjacentTerrainTuple.Item1.ToArray();
            float[] rewards = adjacentTerrainTuple.Item2.ToArray();


            float[] inputs = new float[18];
            int counter = 0;
            for(int i = 0; i < 18; i++){
              if(i < 9){
                inputs[i] = adjacentTerrainElevations[i];
              }
              else{
                inputs[i] = rewards[counter];
                counter++;
              }
            }

            PerceptronFactory perceptron = new PerceptronFactory(18, 2, 2, 9);
            float[] outputs = perceptron.CalculatePerceptronFromId(AnimalId, inputs, AgentMemory);
            outputs.CopyTo(AgentMemory, 0);
            outputs.CopyTo(AgentMemory, outputs.Length);
            Boolean stayPut = false;
            if(outputs[0] >= outputs[1]){
              stayPut = true;
            }


            /**QLearn*/
            List<int[]> adjacentTerrainLocations = GetAdjacentTerrainPositions();
            List<int[]> distantTerrainLocations = GetDistantTerrainPositions();


            //float[] distantTerrainElevations = GetDistantTerrainElevations();


            //change terrainElevations into a matrix
            //adjacentTerrainElevations contains 9 elements, so we need 3x3 matrix
            int index = 0;
            float[,] landscapePatch = new float[3, 3];
            float[,] rewardsPatch = new float[3,3];

            float min = adjacentTerrainElevations[index];
            float max = adjacentTerrainElevations[index];


            // float min = distantTerrainElevations[index];
            // float max = distantTerrainElevations[index];
            for (int x = 0; x < 3; x++) //Getting patch values and turning it into a matrix
            {
                for (int y = 0; y < 3; y++)
                {



                  if(adjacentTerrainElevations[index] < min){
                    min = adjacentTerrainElevations[index];
                  }
                  if(adjacentTerrainElevations[index] > max){
                    max = adjacentTerrainElevations[index];
                  }

                  rewardsPatch[x, y] = rewards[index];
                  landscapePatch[x, y] = adjacentTerrainElevations[index];
                  index++;

                    // if(distantTerrainElevations[index] < min){
                    //   min = distantTerrainElevations[index];
                    // }
                    // if(distantTerrainElevations[index] > max){
                    //   max = distantTerrainElevations[index];
                    // }
                    // landscapePatch[x, y] = distantTerrainElevations[index];
                    // index++;


                }
            }



            int xPos = (int)Position.X;
            int yPos = (int)Position.Y;
            int direction;
            if(stayPut){//don't move cus we on reward
              direction = 4;
            }
            else{
              direction = this.qLearn.getDirection(landscapePatch, rewardsPatch, min, max,this.AnimalId, this.tickNum, Elevation, xPos, yPos); //Which dirction we should be moving
            }
            int[] newLocation = adjacentTerrainLocations[direction]; //direction = 4

            //add location to memory


            //MoveTo (animal object, location, traveling distance)

            Terrain._AnimalEnvironment.MoveTo(this, newLocation[0], newLocation[1], 1, predicate: null);
            this.qLearn.setExportValues(landscapePatch,this.AnimalId, this.tickNum, Elevation, xPos, yPos);
            Elevation = Terrain.GetIntegerValue(this.Position.X, this.Position.Y);
            BioEnergy = (Elevation < 0) ? 0 : Elevation;
            if(stayPut && onReward(rewards)){
              BioEnergy += 10;
            }
            else if(stayPut && !onReward(rewards)){
              BioEnergy = 0;
            }
            this.tickNum++;
        }

        // helper methods

        private Tuple<int, int> InitialPosition()
        {
            //var random = new Random(18);
            //var random = new Random(ID.GetHashCode()); //using hard coded value for testing
            //return new Tuple<int, int>(random.Next(Terrain.DimensionX()), random.Next(Terrain.DimensionY()));
            //make all agents start at same spot
            var random = new Random(); //seed

            //Puts agents on border of map
            //Case 0: Along Y axis (left)
            //Case 1: Along X axis (bottom)
            //Case 2: Along opposite Y axis (right)
            //Case 3: Along opposite X axis (top)
            switch (random.Next(4)){
              case 0:
                return new Tuple<int, int>(0, random.Next(Terrain.DimensionY()));
                break;
              case 1:
                return new Tuple<int, int>(random.Next(Terrain.DimensionX()), 0);
                break;
              case 2:
                return new Tuple<int, int>(Terrain.DimensionX(), random.Next(Terrain.DimensionY()));
                break;
              case 3:
                return new Tuple<int, int>(random.Next(Terrain.DimensionX()),Terrain.DimensionY());
                break;
              default:
                return new Tuple<int, int>(0, 0);
                Console.Write("Default Position");
                break;
            }

        }

        //Looks good will comment header later
        private bool onReward(float[] rewards){

            if(rewards[4] == 1.0f){
              if(memory.ContainsKey(this.AnimalId)){
                for(int i = 0; i < memory[this.AnimalId].Count; i++ ){
                    if(memory[this.AnimalId][i].Item1 == (int)Position.X && memory[this.AnimalId][i].Item2 == (int)Position.Y){//reward has already been collected by agent
                        return false;
                    }
                }
              }
                Tuple<int, int> position = new ((int)Position.X, (int)Position.Y);
                List<Tuple<int, int>> temp = new List<Tuple<int, int>>();
                temp.Add(position);
                if(!memory.TryAdd(this.AnimalId, temp)){
                  temp = memory[this.AnimalId].ToList();
                  temp.Add(position);
                  memory.TryUpdate(this.AnimalId,temp,memory[this.AnimalId]);
                }
                return true;
            }
            return false;
        }

        private Tuple<List<float>, List<float>> GetAdjacentTerrainInfo()
        {
            List<float> elevations = new List<float>();
            List<float> rewards = new List<float>();
            float reward;
            int x = (int)Position.X;
            int y = (int)Position.Y;

            for (int dy = 1; dy >= -1; --dy)
            {
                for (int dx = -1; dx <= 1; ++dx)
                {
                    elevations.Add((int)Terrain.GetRealValue(dx + x, dy + y));
                    reward = (float)Terrain.GetRealValue(dx + x, dy + y)  - (int)Terrain.GetRealValue(dx + x, dy + y); //Should be 0.1 0.0
                    if(reward == 0.0f){
                      rewards.Add(0.0f);
                    }
                    else{
                      if(memory.ContainsKey(this.AnimalId)){
                        Tuple<int, int> position = new (dx + x, dy + y);
                        if(memory[this.AnimalId].Contains(position)){
                          rewards.Add(0.0f);
                        }
                        else{
                          rewards.Add(1.0f);
                        }
                      }//end if memory contains key
                      else{
                        rewards.Add(1.0f);
                      }
                    }//end parent else
                }
            }
            Tuple<List<float>, List<float>> terrain = new (elevations, rewards);

            return terrain;
        }
        //upgrade to 7x7 or 9x9
        private float[] GetDistantTerrainElevations(){
            List<float> elevations = new List<float>();
            int x = (int)Position.X;
            int y = (int)Position.Y;
            for (int dy = 1; dy >= -1; --dy)
            {
                for (int dx = -1; dx <= 1; ++dx)
                {
                    elevations.Add((float)Terrain.GetRealValue(7*dx + x, 7*dy + y));
                }
            }

            return elevations.ToArray();
        }

        private List<int[]> GetAdjacentTerrainPositions()
        {
            List<int[]> locations = new List<int[]>();
            int x = (int)Position.X;
            int y = (int)Position.Y;

            for (int dy = 1; dy >= -1; --dy)
            {
                for (int dx = -1; dx <= 1; ++dx)
                {
                    int[] location = new int[] { dx + x, dy + y };
                    locations.Add(location);
                }
            }

            return locations;
        }

        private List<int[]> GetDistantTerrainPositions()
        {
            List<int[]> locations = new List<int[]>();
            int x = (int)Position.X;
            int y = (int)Position.Y;

            for (int dy = 1; dy >= -1; --dy)
            {
                for (int dx = -1; dx <= 1; ++dx)
                {
                    int[] location = new int[] { 7*dx + x, 7*dy + y };
                    locations.Add(location);
                }
            }

            return locations;
        }


    }
}
